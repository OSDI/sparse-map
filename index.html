<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sparse-map: A C++ implementation of a memory efficient hash map and hash set</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">sparse-map
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">A C++ implementation of a memory efficient hash map and hash set </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b>The library is still in alpha stage.</b></p>
<p>Two classes are provided: <code><a class="el" href="classtsl_1_1sparse__map.html">tsl::sparse_map</a></code> and <code><a class="el" href="classtsl_1_1sparse__set.html">tsl::sparse_set</a></code>.</p>
<h3>Installation</h3>
<p>To use sparse-map, just add the project to your include path. It is a <b>header-only</b> library.</p>
<p>The code should work with any C++11 standard-compliant compiler and has been tested with GCC 4.8.4, Clang 3.5.0 and Visual Studio 2015.</p>
<p>To run the tests you will need the Boost Test library and CMake.</p>
<div class="fragment"><div class="line">git clone https://github.com/Tessil/sparse-map.git</div><div class="line">cd sparse-map</div><div class="line">mkdir build</div><div class="line">cd build</div><div class="line">cmake ..</div><div class="line">make</div><div class="line">./test_sparse_map</div></div><!-- fragment --><h3>Usage</h3>
<p>The API can be found <a href="https://tessil.github.io/sparse-map/">here</a>.</p>
<p>All methods are not documented yet, but they replicate the behavior of the ones in <code>std::unordered_map</code> and <code>std::unordered_set</code>, except if specified otherwise.</p>
<h3>Example</h3>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;cstdint&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;tsl/sparse_map.h&gt;</div><div class="line">#include &lt;tsl/sparse_set.h&gt;</div><div class="line"></div><div class="line">int main() {</div><div class="line">    tsl::sparse_map&lt;std::string, int&gt; map = {{&quot;a&quot;, 1}, {&quot;b&quot;, 2}};</div><div class="line">    map[&quot;c&quot;] = 3;</div><div class="line">    map[&quot;d&quot;] = 4;</div><div class="line"></div><div class="line">    map.insert({&quot;e&quot;, 5});</div><div class="line">    map.erase(&quot;b&quot;);</div><div class="line"></div><div class="line">    for(auto it = map.begin(); it != map.end(); ++it) {</div><div class="line">        //it-&gt;second += 2; // Not valid.</div><div class="line">        it.value() += 2;</div><div class="line">    }</div><div class="line"></div><div class="line">    // {d, 6} {a, 3} {e, 7} {c, 5}</div><div class="line">    for(const auto&amp; key_value : map) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; key_value.first &lt;&lt; &quot;, &quot; &lt;&lt; key_value.second &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    tsl::sparse_set&lt;int&gt; set;</div><div class="line">    set.insert({1, 9, 0});</div><div class="line">    set.insert({2, -1, 9});</div><div class="line"></div><div class="line">    // {0} {1} {2} {9} {-1}</div><div class="line">    for(const auto&amp; key : set) {</div><div class="line">        std::cout &lt;&lt; &quot;{&quot; &lt;&lt; key &lt;&lt; &quot;}&quot; &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">} </div></div><!-- fragment --><h4>Heterogeneous lookups</h4>
<p>Heterogeneous overloads allow the usage of other types than <code>Key</code> for lookup and erase operations as long as the used types are hashable and comparable to <code>Key</code>.</p>
<p>To activate the heterogeneous overloads in <code><a class="el" href="classtsl_1_1sparse__map.html">tsl::sparse_map</a>/set</code>, the qualified-id <code>KeyEqual::is_transparent</code> must be valid. It works the same way as for <a href="http://en.cppreference.com/w/cpp/container/map/find"><code>std::map::find</code></a>. You can either use <a href="http://en.cppreference.com/w/cpp/utility/functional/equal_to_void"><code>std::equal_to&lt;&gt;</code></a> or define your own function object.</p>
<p>Both <code>KeyEqual</code> and <code>Hash</code> will need to be able to deal with the different types.</p>
<div class="fragment"><div class="line">{c++}</div><div class="line">#include &lt;functional&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line">#include &lt;tsl/sparse_map.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">struct employee {</div><div class="line">    employee(int id, std::string name) : m_id(id), m_name(std::move(name)) {</div><div class="line">    }</div><div class="line"></div><div class="line">    friend bool operator==(const employee&amp; empl, int empl_id) {</div><div class="line">        return empl.m_id == empl_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    friend bool operator==(int empl_id, const employee&amp; empl) {</div><div class="line">        return empl_id == empl.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    friend bool operator==(const employee&amp; empl1, const employee&amp; empl2) {</div><div class="line">        return empl1.m_id == empl2.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">    int m_id;</div><div class="line">    std::string m_name;</div><div class="line">};</div><div class="line"></div><div class="line">struct hash_employee {</div><div class="line">    std::size_t operator()(const employee&amp; empl) const {</div><div class="line">        return std::hash&lt;int&gt;()(empl.m_id);</div><div class="line">    }</div><div class="line"></div><div class="line">    std::size_t operator()(int id) const {</div><div class="line">        return std::hash&lt;int&gt;()(id);</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line">struct equal_employee {</div><div class="line">    using is_transparent = void;</div><div class="line"></div><div class="line">    bool operator()(const employee&amp; empl, int empl_id) const {</div><div class="line">        return empl.m_id == empl_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    bool operator()(int empl_id, const employee&amp; empl) const {</div><div class="line">        return empl_id == empl.m_id;</div><div class="line">    }</div><div class="line"></div><div class="line">    bool operator()(const employee&amp; empl1, const employee&amp; empl2) const {</div><div class="line">        return empl1.m_id == empl2.m_id;</div><div class="line">    }</div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line">int main() {</div><div class="line">    // Use std::equal_to&lt;&gt; which will automatically deduce and forward the parameters</div><div class="line">    tsl::sparse_map&lt;employee, int, hash_employee, std::equal_to&lt;&gt;&gt; map; </div><div class="line">    map.insert({employee(1, &quot;John Doe&quot;), 2001});</div><div class="line">    map.insert({employee(2, &quot;Jane Doe&quot;), 2002});</div><div class="line">    map.insert({employee(3, &quot;John Smith&quot;), 2003});</div><div class="line"></div><div class="line">    // John Smith 2003</div><div class="line">    auto it = map.find(3);</div><div class="line">    if(it != map.end()) {</div><div class="line">        std::cout &lt;&lt; it-&gt;first.m_name &lt;&lt; &quot; &quot; &lt;&lt; it-&gt;second &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    map.erase(1);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    // Use a custom KeyEqual which has an is_transparent member type</div><div class="line">    tsl::sparse_map&lt;employee, int, hash_employee, equal_employee&gt; map2;</div><div class="line">    map2.insert({employee(4, &quot;Johnny Doe&quot;), 2004});</div><div class="line"></div><div class="line">    // 2004</div><div class="line">    std::cout &lt;&lt; map2.at(4) &lt;&lt; std::endl;</div><div class="line">}   </div></div><!-- fragment --><h3>License</h3>
<p>The code is licensed under the MIT license, see the [LICENSE file](LICENSE) for details. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
